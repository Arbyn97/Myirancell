{"ast":null,"code":"/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule PrefixIntervalTree\n * \n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _invariant = _interopRequireDefault(require('./../../stubs/invariant'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar parent = function parent(node) {\n  return Math.floor(node / 2);\n};\n\nvar Int32Array = global.Int32Array || function (size) {\n  var xs = [];\n\n  for (var i = size - 1; i >= 0; --i) {\n    xs[i] = 0;\n  }\n\n  return xs;\n};\n/**\n * Computes the next power of 2 after or equal to x.\n */\n\n\nfunction ceilLog2(x) {\n  var y = 1;\n\n  while (y < x) {\n    y *= 2;\n  }\n\n  return y;\n}\n/**\n * A prefix interval tree stores an numeric array and the partial sums of that\n * array. It is optimized for updating the values of the array without\n * recomputing all of the partial sums.\n *\n *   - O(ln n) update\n *   - O(1) lookup\n *   - O(ln n) compute a partial sum\n *   - O(n) space\n *\n * Note that the sequence of partial sums is one longer than the array, so that\n * the first partial sum is always 0, and the last partial sum is the sum of the\n * entire array.\n */\n\n\nvar PrefixIntervalTree = /*#__PURE__*/function () {\n  function PrefixIntervalTree(xs) {\n    _classCallCheck(this, PrefixIntervalTree);\n    /**\n     * Number of elements in the array\n     *\n     * @type {number}\n     * @private\n     */\n\n\n    this._size = xs.length;\n    /**\n     * Half the size of the heap. It is also the number of non-leaf nodes, and the\n     * index of the first element in the heap. Always a power of 2.\n     *\n     * @type {number}\n     * @private\n     */\n\n    this._half = ceilLog2(this._size);\n    /**\n     * Binary heap\n     *\n     * @type {!Array.<number>}\n     * @const\n     * @private\n     */\n\n    this._heap = new Int32Array(2 * this._half);\n    var i;\n\n    for (i = 0; i < this._size; ++i) {\n      this._heap[this._half + i] = xs[i];\n    }\n\n    for (i = this._half - 1; i > 0; --i) {\n      this._heap[i] = this._heap[2 * i] + this._heap[2 * i + 1];\n    }\n  }\n\n  _createClass(PrefixIntervalTree, [{\n    key: \"set\",\n    value: function set(index, value) {\n      (0, _invariant[\"default\"])(0 <= index && index < this._size, 'Index out of range %s', index);\n      var node = this._half + index;\n      this._heap[node] = value;\n      node = parent(node);\n\n      for (; node !== 0; node = parent(node)) {\n        this._heap[node] = this._heap[2 * node] + this._heap[2 * node + 1];\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      (0, _invariant[\"default\"])(0 <= index && index < this._size, 'Index out of range %s', index);\n      var node = this._half + index;\n      return this._heap[node];\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      return this._size;\n    }\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(end - 1).\n     */\n\n  }, {\n    key: \"sumUntil\",\n    value: function sumUntil(end) {\n      (0, _invariant[\"default\"])(0 <= end && end < this._size + 1, 'Index out of range %s', end);\n\n      if (end === 0) {\n        return 0;\n      }\n\n      var node = this._half + end - 1;\n      var sum = this._heap[node];\n\n      for (; node !== 1; node = parent(node)) {\n        if (node % 2 === 1) {\n          sum += this._heap[node - 1];\n        }\n      }\n\n      return sum;\n    }\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(inclusiveEnd).\n     */\n\n  }, {\n    key: \"sumTo\",\n    value: function sumTo(inclusiveEnd) {\n      (0, _invariant[\"default\"])(0 <= inclusiveEnd && inclusiveEnd < this._size, 'Index out of range %s', inclusiveEnd);\n      return this.sumUntil(inclusiveEnd + 1);\n    }\n    /**\n     * Returns the sum get(begin) + get(begin + 1) + ... + get(end - 1).\n     */\n\n  }, {\n    key: \"sum\",\n    value: function sum(begin, end) {\n      (0, _invariant[\"default\"])(begin <= end, 'Begin must precede end');\n      return this.sumUntil(end) - this.sumUntil(begin);\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) <= t, or\n     * -1 if no such i exists.\n     */\n\n  }, {\n    key: \"greatestLowerBound\",\n    value: function greatestLowerBound(t) {\n      if (t < 0) {\n        return -1;\n      }\n\n      var node = 1;\n\n      if (this._heap[node] <= t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n\n        if (t < leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) < t, or\n     * -1 if no such i exists.\n     */\n\n  }, {\n    key: \"greatestStrictLowerBound\",\n    value: function greatestStrictLowerBound(t) {\n      if (t <= 0) {\n        return -1;\n      }\n\n      var node = 1;\n\n      if (this._heap[node] < t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n\n        if (t <= leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t <= sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n\n  }, {\n    key: \"leastUpperBound\",\n    value: function leastUpperBound(t) {\n      return this.greatestStrictLowerBound(t) + 1;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t < sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n\n  }, {\n    key: \"leastStrictUpperBound\",\n    value: function leastStrictUpperBound(t) {\n      return this.greatestLowerBound(t) + 1;\n    }\n  }], [{\n    key: \"uniform\",\n    value: function uniform(size, initialValue) {\n      var xs = [];\n\n      for (var i = size - 1; i >= 0; --i) {\n        xs[i] = initialValue;\n      }\n\n      return new PrefixIntervalTree(xs);\n    }\n  }, {\n    key: \"empty\",\n    value: function empty(size) {\n      return PrefixIntervalTree.uniform(size, 0);\n    }\n  }]);\n\n  return PrefixIntervalTree;\n}();\n\nvar _default = PrefixIntervalTree;\nexports[\"default\"] = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","_invariant","_interopRequireDefault","require","obj","__esModule","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","parent","node","Math","floor","Int32Array","global","size","xs","ceilLog2","x","y","PrefixIntervalTree","_size","_half","_heap","set","index","get","getSize","sumUntil","end","sum","sumTo","inclusiveEnd","begin","greatestLowerBound","t","leftSum","greatestStrictLowerBound","leastUpperBound","leastStrictUpperBound","uniform","initialValue","empty","_default"],"sources":["D:/myirancell/myirancell/node_modules/fixed-data-table-2/internal/vendor_upstream/struct/PrefixIntervalTree.js"],"sourcesContent":["/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule PrefixIntervalTree\n * \n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _invariant = _interopRequireDefault(require('./../../stubs/invariant'));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar parent = function parent(node) {\n  return Math.floor(node / 2);\n};\n\nvar Int32Array = global.Int32Array || function (size) {\n  var xs = [];\n\n  for (var i = size - 1; i >= 0; --i) {\n    xs[i] = 0;\n  }\n\n  return xs;\n};\n/**\n * Computes the next power of 2 after or equal to x.\n */\n\n\nfunction ceilLog2(x) {\n  var y = 1;\n\n  while (y < x) {\n    y *= 2;\n  }\n\n  return y;\n}\n/**\n * A prefix interval tree stores an numeric array and the partial sums of that\n * array. It is optimized for updating the values of the array without\n * recomputing all of the partial sums.\n *\n *   - O(ln n) update\n *   - O(1) lookup\n *   - O(ln n) compute a partial sum\n *   - O(n) space\n *\n * Note that the sequence of partial sums is one longer than the array, so that\n * the first partial sum is always 0, and the last partial sum is the sum of the\n * entire array.\n */\n\n\nvar PrefixIntervalTree = /*#__PURE__*/function () {\n  function PrefixIntervalTree(xs) {\n    _classCallCheck(this, PrefixIntervalTree);\n\n    /**\n     * Number of elements in the array\n     *\n     * @type {number}\n     * @private\n     */\n    this._size = xs.length;\n    /**\n     * Half the size of the heap. It is also the number of non-leaf nodes, and the\n     * index of the first element in the heap. Always a power of 2.\n     *\n     * @type {number}\n     * @private\n     */\n\n    this._half = ceilLog2(this._size);\n    /**\n     * Binary heap\n     *\n     * @type {!Array.<number>}\n     * @const\n     * @private\n     */\n\n    this._heap = new Int32Array(2 * this._half);\n    var i;\n\n    for (i = 0; i < this._size; ++i) {\n      this._heap[this._half + i] = xs[i];\n    }\n\n    for (i = this._half - 1; i > 0; --i) {\n      this._heap[i] = this._heap[2 * i] + this._heap[2 * i + 1];\n    }\n  }\n\n  _createClass(PrefixIntervalTree, [{\n    key: \"set\",\n    value: function set(index, value) {\n      (0, _invariant[\"default\"])(0 <= index && index < this._size, 'Index out of range %s', index);\n      var node = this._half + index;\n      this._heap[node] = value;\n      node = parent(node);\n\n      for (; node !== 0; node = parent(node)) {\n        this._heap[node] = this._heap[2 * node] + this._heap[2 * node + 1];\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      (0, _invariant[\"default\"])(0 <= index && index < this._size, 'Index out of range %s', index);\n      var node = this._half + index;\n      return this._heap[node];\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      return this._size;\n    }\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(end - 1).\n     */\n\n  }, {\n    key: \"sumUntil\",\n    value: function sumUntil(end) {\n      (0, _invariant[\"default\"])(0 <= end && end < this._size + 1, 'Index out of range %s', end);\n\n      if (end === 0) {\n        return 0;\n      }\n\n      var node = this._half + end - 1;\n      var sum = this._heap[node];\n\n      for (; node !== 1; node = parent(node)) {\n        if (node % 2 === 1) {\n          sum += this._heap[node - 1];\n        }\n      }\n\n      return sum;\n    }\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(inclusiveEnd).\n     */\n\n  }, {\n    key: \"sumTo\",\n    value: function sumTo(inclusiveEnd) {\n      (0, _invariant[\"default\"])(0 <= inclusiveEnd && inclusiveEnd < this._size, 'Index out of range %s', inclusiveEnd);\n      return this.sumUntil(inclusiveEnd + 1);\n    }\n    /**\n     * Returns the sum get(begin) + get(begin + 1) + ... + get(end - 1).\n     */\n\n  }, {\n    key: \"sum\",\n    value: function sum(begin, end) {\n      (0, _invariant[\"default\"])(begin <= end, 'Begin must precede end');\n      return this.sumUntil(end) - this.sumUntil(begin);\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) <= t, or\n     * -1 if no such i exists.\n     */\n\n  }, {\n    key: \"greatestLowerBound\",\n    value: function greatestLowerBound(t) {\n      if (t < 0) {\n        return -1;\n      }\n\n      var node = 1;\n\n      if (this._heap[node] <= t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n\n        if (t < leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) < t, or\n     * -1 if no such i exists.\n     */\n\n  }, {\n    key: \"greatestStrictLowerBound\",\n    value: function greatestStrictLowerBound(t) {\n      if (t <= 0) {\n        return -1;\n      }\n\n      var node = 1;\n\n      if (this._heap[node] < t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n\n        if (t <= leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t <= sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n\n  }, {\n    key: \"leastUpperBound\",\n    value: function leastUpperBound(t) {\n      return this.greatestStrictLowerBound(t) + 1;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t < sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n\n  }, {\n    key: \"leastStrictUpperBound\",\n    value: function leastStrictUpperBound(t) {\n      return this.greatestLowerBound(t) + 1;\n    }\n  }], [{\n    key: \"uniform\",\n    value: function uniform(size, initialValue) {\n      var xs = [];\n\n      for (var i = size - 1; i >= 0; --i) {\n        xs[i] = initialValue;\n      }\n\n      return new PrefixIntervalTree(xs);\n    }\n  }, {\n    key: \"empty\",\n    value: function empty(size) {\n      return PrefixIntervalTree.uniform(size, 0);\n    }\n  }]);\n\n  return PrefixIntervalTree;\n}();\n\nvar _default = PrefixIntervalTree;\nexports[\"default\"] = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}