{"ast":null,"code":"/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule scrollAnchor\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getScrollAnchor = getScrollAnchor;\nexports.scrollTo = scrollTo;\n\nvar _clamp = _interopRequireDefault(require('./../vendor_upstream/core/clamp'));\n\nvar _scrollbarsVisible = _interopRequireDefault(require('./../selectors/scrollbarsVisible'));\n\nvar _updateRowHeight = _interopRequireDefault(require('././updateRowHeight'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * Get the anchor for scrolling.\n * This will either be the first row's index and an offset, or the last row's index.\n * We also pass a flag indicating if the anchor has changed from the state\n *\n * @param {!Object} state\n * @param {!Object} newProps\n * @param {!Object} [oldProps]\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n */\n\n\nfunction getScrollAnchor(state, newProps, oldProps) {\n  if (newProps.scrollToRow !== undefined && newProps.scrollToRow !== null && (!oldProps || newProps.scrollToRow !== oldProps.scrollToRow)) {\n    return scrollToRow(state, newProps.scrollToRow);\n  }\n\n  if (newProps.scrollTop !== undefined && newProps.scrollTop !== null && (!oldProps || newProps.scrollTop !== oldProps.scrollTop)) {\n    return scrollTo(state, newProps.scrollTop);\n  }\n\n  return {\n    firstIndex: state.firstRowIndex,\n    firstOffset: state.firstRowOffset,\n    lastIndex: undefined,\n    changed: false\n  };\n}\n/**\n * Scroll to a specific position in the grid\n *\n * @param {!Object} state\n * @param {number} scrollY\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n */\n\n\nfunction scrollTo(state, scrollY) {\n  var _scrollbarsVisibleSel = (0, _scrollbarsVisible[\"default\"])(state),\n      availableHeight = _scrollbarsVisibleSel.availableHeight;\n\n  var rowOffsetIntervalTree = state.rowOffsetIntervalTree,\n      rowSettings = state.rowSettings,\n      scrollContentHeight = state.scrollContentHeight;\n  var rowsCount = rowSettings.rowsCount;\n\n  if (rowsCount === 0) {\n    return {\n      firstIndex: 0,\n      firstOffset: 0,\n      lastIndex: undefined,\n      changed: state.firstRowIndex !== 0 || state.firstRowOffset !== 0\n    };\n  }\n\n  var firstIndex = 0;\n  var firstOffset = 0;\n  var lastIndex = undefined;\n\n  if (scrollY <= 0) {// Use defaults (from above) to scroll to first row\n  } else if (scrollY >= scrollContentHeight - availableHeight) {\n    // Scroll to the last row\n    firstIndex = undefined;\n    lastIndex = rowsCount - 1;\n  } else {\n    // Mark the row which will appear first in the viewport\n    // We use this as our \"marker\" when scrolling even if updating rowOffsets\n    // leads to it not being different from the scrollY specified\n    var newRowIdx = rowOffsetIntervalTree.greatestLowerBound(scrollY);\n    firstIndex = (0, _clamp[\"default\"])(newRowIdx, 0, Math.max(rowsCount - 1, 0)); // Record how far into the first row we should scroll\n    // firstOffset is a negative value representing how much larger scrollY is\n    // than the scroll position of the first row in the viewport\n\n    var firstRowPosition = rowOffsetIntervalTree.sumUntil(firstIndex);\n    firstOffset = firstRowPosition - scrollY;\n  }\n\n  return {\n    firstIndex: firstIndex,\n    firstOffset: firstOffset,\n    lastIndex: lastIndex,\n    // NOTE (jordan) This changed heuristic may give false positives,\n    // but that's fine since it's used as a filter to computeRenderedRows\n    changed: true\n  };\n}\n/**\n * Scroll a specified row into the viewport\n * If the row is before the viewport, it will become the first row in the viewport\n * If the row is after the viewport, it will become the last row in the viewport\n * If the row is in the viewport, do nothing\n *\n * @param {!Object} state\n * @param {number} rowIndex\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n * @private\n */\n\n\nfunction scrollToRow(state, rowIndex) {\n  var _scrollbarsVisibleSel2 = (0, _scrollbarsVisible[\"default\"])(state),\n      availableHeight = _scrollbarsVisibleSel2.availableHeight;\n\n  var rowOffsetIntervalTree = state.rowOffsetIntervalTree,\n      rowSettings = state.rowSettings,\n      storedHeights = state.storedHeights,\n      scrollY = state.scrollY;\n  var rowsCount = rowSettings.rowsCount;\n\n  if (rowsCount === 0) {\n    return {\n      firstIndex: 0,\n      firstOffset: 0,\n      lastIndex: undefined,\n      changed: state.firstRowIndex !== 0 || state.firstRowOffset !== 0\n    };\n  }\n\n  rowIndex = (0, _clamp[\"default\"])(rowIndex, 0, Math.max(rowsCount - 1, 0));\n  (0, _updateRowHeight[\"default\"])(state, rowIndex);\n  var rowBegin = rowOffsetIntervalTree.sumUntil(rowIndex);\n  var rowEnd = rowBegin + storedHeights[rowIndex];\n  var firstIndex = rowIndex;\n  var lastIndex = undefined;\n\n  if (rowBegin < scrollY) {// If before the viewport, set as the first row in the viewport\n    // Uses defaults (from above)\n  } else if (scrollY + availableHeight < rowEnd) {\n    // If after the viewport, set as the last row in the viewport\n    firstIndex = undefined;\n    lastIndex = rowIndex;\n  } else {\n    // If already in the viewport, do nothing.\n    return {\n      firstIndex: state.firstRowIndex,\n      firstOffset: state.firstRowOffset,\n      lastIndex: undefined,\n      changed: false\n    };\n  }\n\n  return {\n    firstIndex: firstIndex,\n    firstOffset: 0,\n    lastIndex: lastIndex,\n    changed: true\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getScrollAnchor","scrollTo","_clamp","_interopRequireDefault","require","_scrollbarsVisible","_updateRowHeight","obj","__esModule","state","newProps","oldProps","scrollToRow","undefined","scrollTop","firstIndex","firstRowIndex","firstOffset","firstRowOffset","lastIndex","changed","scrollY","_scrollbarsVisibleSel","availableHeight","rowOffsetIntervalTree","rowSettings","scrollContentHeight","rowsCount","newRowIdx","greatestLowerBound","Math","max","firstRowPosition","sumUntil","rowIndex","_scrollbarsVisibleSel2","storedHeights","rowBegin","rowEnd"],"sources":["D:/myirancell/myirancell/node_modules/fixed-data-table-2/internal/reducers/scrollAnchor.js"],"sourcesContent":["/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule scrollAnchor\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getScrollAnchor = getScrollAnchor;\nexports.scrollTo = scrollTo;\n\nvar _clamp = _interopRequireDefault(require('./../vendor_upstream/core/clamp'));\n\nvar _scrollbarsVisible = _interopRequireDefault(require('./../selectors/scrollbarsVisible'));\n\nvar _updateRowHeight = _interopRequireDefault(require('././updateRowHeight'));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Get the anchor for scrolling.\n * This will either be the first row's index and an offset, or the last row's index.\n * We also pass a flag indicating if the anchor has changed from the state\n *\n * @param {!Object} state\n * @param {!Object} newProps\n * @param {!Object} [oldProps]\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n */\nfunction getScrollAnchor(state, newProps, oldProps) {\n  if (newProps.scrollToRow !== undefined && newProps.scrollToRow !== null && (!oldProps || newProps.scrollToRow !== oldProps.scrollToRow)) {\n    return scrollToRow(state, newProps.scrollToRow);\n  }\n\n  if (newProps.scrollTop !== undefined && newProps.scrollTop !== null && (!oldProps || newProps.scrollTop !== oldProps.scrollTop)) {\n    return scrollTo(state, newProps.scrollTop);\n  }\n\n  return {\n    firstIndex: state.firstRowIndex,\n    firstOffset: state.firstRowOffset,\n    lastIndex: undefined,\n    changed: false\n  };\n}\n/**\n * Scroll to a specific position in the grid\n *\n * @param {!Object} state\n * @param {number} scrollY\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n */\n\n\nfunction scrollTo(state, scrollY) {\n  var _scrollbarsVisibleSel = (0, _scrollbarsVisible[\"default\"])(state),\n      availableHeight = _scrollbarsVisibleSel.availableHeight;\n\n  var rowOffsetIntervalTree = state.rowOffsetIntervalTree,\n      rowSettings = state.rowSettings,\n      scrollContentHeight = state.scrollContentHeight;\n  var rowsCount = rowSettings.rowsCount;\n\n  if (rowsCount === 0) {\n    return {\n      firstIndex: 0,\n      firstOffset: 0,\n      lastIndex: undefined,\n      changed: state.firstRowIndex !== 0 || state.firstRowOffset !== 0\n    };\n  }\n\n  var firstIndex = 0;\n  var firstOffset = 0;\n  var lastIndex = undefined;\n\n  if (scrollY <= 0) {// Use defaults (from above) to scroll to first row\n  } else if (scrollY >= scrollContentHeight - availableHeight) {\n    // Scroll to the last row\n    firstIndex = undefined;\n    lastIndex = rowsCount - 1;\n  } else {\n    // Mark the row which will appear first in the viewport\n    // We use this as our \"marker\" when scrolling even if updating rowOffsets\n    // leads to it not being different from the scrollY specified\n    var newRowIdx = rowOffsetIntervalTree.greatestLowerBound(scrollY);\n    firstIndex = (0, _clamp[\"default\"])(newRowIdx, 0, Math.max(rowsCount - 1, 0)); // Record how far into the first row we should scroll\n    // firstOffset is a negative value representing how much larger scrollY is\n    // than the scroll position of the first row in the viewport\n\n    var firstRowPosition = rowOffsetIntervalTree.sumUntil(firstIndex);\n    firstOffset = firstRowPosition - scrollY;\n  }\n\n  return {\n    firstIndex: firstIndex,\n    firstOffset: firstOffset,\n    lastIndex: lastIndex,\n    // NOTE (jordan) This changed heuristic may give false positives,\n    // but that's fine since it's used as a filter to computeRenderedRows\n    changed: true\n  };\n}\n/**\n * Scroll a specified row into the viewport\n * If the row is before the viewport, it will become the first row in the viewport\n * If the row is after the viewport, it will become the last row in the viewport\n * If the row is in the viewport, do nothing\n *\n * @param {!Object} state\n * @param {number} rowIndex\n * @return {{\n *   firstIndex: number,\n *   firstOffset: number,\n *   lastIndex: number,\n *   changed: boolean,\n * }}\n * @private\n */\n\n\nfunction scrollToRow(state, rowIndex) {\n  var _scrollbarsVisibleSel2 = (0, _scrollbarsVisible[\"default\"])(state),\n      availableHeight = _scrollbarsVisibleSel2.availableHeight;\n\n  var rowOffsetIntervalTree = state.rowOffsetIntervalTree,\n      rowSettings = state.rowSettings,\n      storedHeights = state.storedHeights,\n      scrollY = state.scrollY;\n  var rowsCount = rowSettings.rowsCount;\n\n  if (rowsCount === 0) {\n    return {\n      firstIndex: 0,\n      firstOffset: 0,\n      lastIndex: undefined,\n      changed: state.firstRowIndex !== 0 || state.firstRowOffset !== 0\n    };\n  }\n\n  rowIndex = (0, _clamp[\"default\"])(rowIndex, 0, Math.max(rowsCount - 1, 0));\n  (0, _updateRowHeight[\"default\"])(state, rowIndex);\n  var rowBegin = rowOffsetIntervalTree.sumUntil(rowIndex);\n  var rowEnd = rowBegin + storedHeights[rowIndex];\n  var firstIndex = rowIndex;\n  var lastIndex = undefined;\n\n  if (rowBegin < scrollY) {// If before the viewport, set as the first row in the viewport\n    // Uses defaults (from above)\n  } else if (scrollY + availableHeight < rowEnd) {\n    // If after the viewport, set as the last row in the viewport\n    firstIndex = undefined;\n    lastIndex = rowIndex;\n  } else {\n    // If already in the viewport, do nothing.\n    return {\n      firstIndex: state.firstRowIndex,\n      firstOffset: state.firstRowOffset,\n      lastIndex: undefined,\n      changed: false\n    };\n  }\n\n  return {\n    firstIndex: firstIndex,\n    firstOffset: 0,\n    lastIndex: lastIndex,\n    changed: true\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}