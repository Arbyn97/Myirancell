{"ast":null,"code":"/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule IntegerBufferSet\n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Heap = _interopRequireDefault(require('././Heap'));\n\nvar _invariant = _interopRequireDefault(require('./../../stubs/invariant'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // Data structure that allows to store values and assign positions to them\n// in a way to minimize changing positions of stored values when new ones are\n// added or when some values are replaced. Stored elements are alwasy assigned\n// a consecutive set of positoins startin from 0 up to count of elements less 1\n// Following actions can be executed\n// * get position assigned to given value (null if value is not stored)\n// * create new entry for new value and get assigned position back\n// * replace value that is furthest from specified value range with new value\n//   and get it's position back\n// All operations take amortized log(n) time where n is number of elements in\n// the set.\n\n\nvar IntegerBufferSet = /*#__PURE__*/function () {\n  function IntegerBufferSet() {\n    _classCallCheck(this, IntegerBufferSet);\n\n    this._valueToPositionMap = {};\n    this._size = 0;\n    this._smallValues = new _Heap[\"default\"]([], // Initial data in the heap\n    this._smallerComparator);\n    this._largeValues = new _Heap[\"default\"]([], // Initial data in the heap\n    this._greaterComparator);\n    this.getNewPositionForValue = this.getNewPositionForValue.bind(this);\n    this.getValuePosition = this.getValuePosition.bind(this);\n    this.getSize = this.getSize.bind(this);\n    this.replaceFurthestValuePosition = this.replaceFurthestValuePosition.bind(this);\n  }\n\n  _createClass(IntegerBufferSet, [{\n    key: \"getSize\",\n    value: function getSize()\n    /*number*/\n    {\n      return this._size;\n    }\n  }, {\n    key: \"getValuePosition\",\n    value: function getValuePosition(\n    /*number*/\n    value)\n    /*?number*/\n    {\n      if (this._valueToPositionMap[value] === undefined) {\n        return null;\n      }\n\n      return this._valueToPositionMap[value];\n    }\n  }, {\n    key: \"getNewPositionForValue\",\n    value: function getNewPositionForValue(\n    /*number*/\n    value)\n    /*number*/\n    {\n      (0, _invariant[\"default\"])(this._valueToPositionMap[value] === undefined, \"Shouldn't try to find new position for value already stored in BufferSet\");\n      var newPosition = this._size;\n      this._size++;\n\n      this._pushToHeaps(newPosition, value);\n\n      this._valueToPositionMap[value] = newPosition;\n      return newPosition;\n    }\n  }, {\n    key: \"replaceFurthestValuePosition\",\n    value: function replaceFurthestValuePosition(\n    /*number*/\n    lowValue,\n    /*number*/\n    highValue,\n    /*number*/\n    newValue)\n    /*?number*/\n    {\n      (0, _invariant[\"default\"])(this._valueToPositionMap[newValue] === undefined, \"Shouldn't try to replace values with value already stored value in \" + 'BufferSet');\n\n      this._cleanHeaps();\n\n      if (this._smallValues.empty() || this._largeValues.empty()) {\n        // Threre are currently no values stored. We will have to create new\n        // position for this value.\n        return null;\n      }\n\n      var minValue = this._smallValues.peek().value;\n\n      var maxValue = this._largeValues.peek().value;\n\n      if (minValue >= lowValue && maxValue <= highValue) {\n        // All values currently stored are necessary, we can't reuse any of them.\n        return null;\n      }\n\n      var valueToReplace;\n\n      if (lowValue - minValue > maxValue - highValue) {\n        // minValue is further from provided range. We will reuse it's position.\n        valueToReplace = minValue;\n\n        this._smallValues.pop();\n      } else {\n        valueToReplace = maxValue;\n\n        this._largeValues.pop();\n      }\n\n      var position = this._valueToPositionMap[valueToReplace];\n      delete this._valueToPositionMap[valueToReplace];\n      this._valueToPositionMap[newValue] = position;\n\n      this._pushToHeaps(position, newValue);\n\n      return position;\n    }\n  }, {\n    key: \"_pushToHeaps\",\n    value: function _pushToHeaps(\n    /*number*/\n    position,\n    /*number*/\n    value) {\n      var element = {\n        position: position,\n        value: value\n      }; // We can reuse the same object in both heaps, because we don't mutate them\n\n      this._smallValues.push(element);\n\n      this._largeValues.push(element);\n    }\n  }, {\n    key: \"_cleanHeaps\",\n    value: function _cleanHeaps() {\n      // We not usually only remove object from one heap while moving value.\n      // Here we make sure that there is no stale data on top of heaps.\n      this._cleanHeap(this._smallValues);\n\n      this._cleanHeap(this._largeValues);\n\n      var minHeapSize = Math.min(this._smallValues.size(), this._largeValues.size());\n      var maxHeapSize = Math.max(this._smallValues.size(), this._largeValues.size());\n\n      if (maxHeapSize > 10 * minHeapSize) {\n        // There are many old values in one of heaps. We nned to get rid of them\n        // to not use too avoid memory leaks\n        this._recreateHeaps();\n      }\n    }\n  }, {\n    key: \"_recreateHeaps\",\n    value: function _recreateHeaps() {\n      var sourceHeap = this._smallValues.size() < this._largeValues.size() ? this._smallValues : this._largeValues;\n      var newSmallValues = new _Heap[\"default\"]([], // Initial data in the heap\n      this._smallerComparator);\n      var newLargeValues = new _Heap[\"default\"]([], // Initial datat in the heap\n      this._greaterComparator);\n\n      while (!sourceHeap.empty()) {\n        var element = sourceHeap.pop(); // Push all stil valid elements to new heaps\n\n        if (this._valueToPositionMap[element.value] !== undefined) {\n          newSmallValues.push(element);\n          newLargeValues.push(element);\n        }\n      }\n\n      this._smallValues = newSmallValues;\n      this._largeValues = newLargeValues;\n    }\n  }, {\n    key: \"_cleanHeap\",\n    value: function _cleanHeap(\n    /*object*/\n    heap) {\n      while (!heap.empty() && this._valueToPositionMap[heap.peek().value] === undefined) {\n        heap.pop();\n      }\n    }\n  }, {\n    key: \"_smallerComparator\",\n    value: function _smallerComparator(\n    /*object*/\n    lhs,\n    /*object*/\n    rhs)\n    /*boolean*/\n    {\n      return lhs.value < rhs.value;\n    }\n  }, {\n    key: \"_greaterComparator\",\n    value: function _greaterComparator(\n    /*object*/\n    lhs,\n    /*object*/\n    rhs)\n    /*boolean*/\n    {\n      return lhs.value > rhs.value;\n    }\n  }]);\n\n  return IntegerBufferSet;\n}();\n\nvar _default = IntegerBufferSet;\nexports[\"default\"] = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","_Heap","_interopRequireDefault","require","_invariant","obj","__esModule","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","IntegerBufferSet","_valueToPositionMap","_size","_smallValues","_smallerComparator","_largeValues","_greaterComparator","getNewPositionForValue","bind","getValuePosition","getSize","replaceFurthestValuePosition","undefined","newPosition","_pushToHeaps","lowValue","highValue","newValue","_cleanHeaps","empty","minValue","peek","maxValue","valueToReplace","pop","position","element","push","_cleanHeap","minHeapSize","Math","min","size","maxHeapSize","max","_recreateHeaps","sourceHeap","newSmallValues","newLargeValues","heap","lhs","rhs","_default"],"sources":["D:/myirancell/myirancell/node_modules/fixed-data-table-2/internal/vendor_upstream/struct/IntegerBufferSet.js"],"sourcesContent":["/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule IntegerBufferSet\n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _Heap = _interopRequireDefault(require('././Heap'));\n\nvar _invariant = _interopRequireDefault(require('./../../stubs/invariant'));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Data structure that allows to store values and assign positions to them\n// in a way to minimize changing positions of stored values when new ones are\n// added or when some values are replaced. Stored elements are alwasy assigned\n// a consecutive set of positoins startin from 0 up to count of elements less 1\n// Following actions can be executed\n// * get position assigned to given value (null if value is not stored)\n// * create new entry for new value and get assigned position back\n// * replace value that is furthest from specified value range with new value\n//   and get it's position back\n// All operations take amortized log(n) time where n is number of elements in\n// the set.\nvar IntegerBufferSet = /*#__PURE__*/function () {\n  function IntegerBufferSet() {\n    _classCallCheck(this, IntegerBufferSet);\n\n    this._valueToPositionMap = {};\n    this._size = 0;\n    this._smallValues = new _Heap[\"default\"]([], // Initial data in the heap\n    this._smallerComparator);\n    this._largeValues = new _Heap[\"default\"]([], // Initial data in the heap\n    this._greaterComparator);\n    this.getNewPositionForValue = this.getNewPositionForValue.bind(this);\n    this.getValuePosition = this.getValuePosition.bind(this);\n    this.getSize = this.getSize.bind(this);\n    this.replaceFurthestValuePosition = this.replaceFurthestValuePosition.bind(this);\n  }\n\n  _createClass(IntegerBufferSet, [{\n    key: \"getSize\",\n    value: function getSize()\n    /*number*/\n    {\n      return this._size;\n    }\n  }, {\n    key: \"getValuePosition\",\n    value: function getValuePosition(\n    /*number*/\n    value)\n    /*?number*/\n    {\n      if (this._valueToPositionMap[value] === undefined) {\n        return null;\n      }\n\n      return this._valueToPositionMap[value];\n    }\n  }, {\n    key: \"getNewPositionForValue\",\n    value: function getNewPositionForValue(\n    /*number*/\n    value)\n    /*number*/\n    {\n      (0, _invariant[\"default\"])(this._valueToPositionMap[value] === undefined, \"Shouldn't try to find new position for value already stored in BufferSet\");\n      var newPosition = this._size;\n      this._size++;\n\n      this._pushToHeaps(newPosition, value);\n\n      this._valueToPositionMap[value] = newPosition;\n      return newPosition;\n    }\n  }, {\n    key: \"replaceFurthestValuePosition\",\n    value: function replaceFurthestValuePosition(\n    /*number*/\n    lowValue,\n    /*number*/\n    highValue,\n    /*number*/\n    newValue)\n    /*?number*/\n    {\n      (0, _invariant[\"default\"])(this._valueToPositionMap[newValue] === undefined, \"Shouldn't try to replace values with value already stored value in \" + 'BufferSet');\n\n      this._cleanHeaps();\n\n      if (this._smallValues.empty() || this._largeValues.empty()) {\n        // Threre are currently no values stored. We will have to create new\n        // position for this value.\n        return null;\n      }\n\n      var minValue = this._smallValues.peek().value;\n\n      var maxValue = this._largeValues.peek().value;\n\n      if (minValue >= lowValue && maxValue <= highValue) {\n        // All values currently stored are necessary, we can't reuse any of them.\n        return null;\n      }\n\n      var valueToReplace;\n\n      if (lowValue - minValue > maxValue - highValue) {\n        // minValue is further from provided range. We will reuse it's position.\n        valueToReplace = minValue;\n\n        this._smallValues.pop();\n      } else {\n        valueToReplace = maxValue;\n\n        this._largeValues.pop();\n      }\n\n      var position = this._valueToPositionMap[valueToReplace];\n      delete this._valueToPositionMap[valueToReplace];\n      this._valueToPositionMap[newValue] = position;\n\n      this._pushToHeaps(position, newValue);\n\n      return position;\n    }\n  }, {\n    key: \"_pushToHeaps\",\n    value: function _pushToHeaps(\n    /*number*/\n    position,\n    /*number*/\n    value) {\n      var element = {\n        position: position,\n        value: value\n      }; // We can reuse the same object in both heaps, because we don't mutate them\n\n      this._smallValues.push(element);\n\n      this._largeValues.push(element);\n    }\n  }, {\n    key: \"_cleanHeaps\",\n    value: function _cleanHeaps() {\n      // We not usually only remove object from one heap while moving value.\n      // Here we make sure that there is no stale data on top of heaps.\n      this._cleanHeap(this._smallValues);\n\n      this._cleanHeap(this._largeValues);\n\n      var minHeapSize = Math.min(this._smallValues.size(), this._largeValues.size());\n      var maxHeapSize = Math.max(this._smallValues.size(), this._largeValues.size());\n\n      if (maxHeapSize > 10 * minHeapSize) {\n        // There are many old values in one of heaps. We nned to get rid of them\n        // to not use too avoid memory leaks\n        this._recreateHeaps();\n      }\n    }\n  }, {\n    key: \"_recreateHeaps\",\n    value: function _recreateHeaps() {\n      var sourceHeap = this._smallValues.size() < this._largeValues.size() ? this._smallValues : this._largeValues;\n      var newSmallValues = new _Heap[\"default\"]([], // Initial data in the heap\n      this._smallerComparator);\n      var newLargeValues = new _Heap[\"default\"]([], // Initial datat in the heap\n      this._greaterComparator);\n\n      while (!sourceHeap.empty()) {\n        var element = sourceHeap.pop(); // Push all stil valid elements to new heaps\n\n        if (this._valueToPositionMap[element.value] !== undefined) {\n          newSmallValues.push(element);\n          newLargeValues.push(element);\n        }\n      }\n\n      this._smallValues = newSmallValues;\n      this._largeValues = newLargeValues;\n    }\n  }, {\n    key: \"_cleanHeap\",\n    value: function _cleanHeap(\n    /*object*/\n    heap) {\n      while (!heap.empty() && this._valueToPositionMap[heap.peek().value] === undefined) {\n        heap.pop();\n      }\n    }\n  }, {\n    key: \"_smallerComparator\",\n    value: function _smallerComparator(\n    /*object*/\n    lhs,\n    /*object*/\n    rhs)\n    /*boolean*/\n    {\n      return lhs.value < rhs.value;\n    }\n  }, {\n    key: \"_greaterComparator\",\n    value: function _greaterComparator(\n    /*object*/\n    lhs,\n    /*object*/\n    rhs)\n    /*boolean*/\n    {\n      return lhs.value > rhs.value;\n    }\n  }]);\n\n  return IntegerBufferSet;\n}();\n\nvar _default = IntegerBufferSet;\nexports[\"default\"] = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}