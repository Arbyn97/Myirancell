{"ast":null,"code":"/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * This is utility that handles touch events and calls provided touch\n * callback with correct frame rate.\n * Deceleration logic based on http://ariya.ofilabs.com/2013/11/javascript-kinetic-scrolling-part-2.html\n *\n * @providesModule ReactTouchHandler\n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _emptyFunction = _interopRequireDefault(require('././vendor_upstream/core/emptyFunction'));\n\nvar _requestAnimationFramePolyfill = _interopRequireDefault(require('././vendor_upstream/core/requestAnimationFramePolyfill'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar MOVE_AMPLITUDE = 1.6;\nvar DECELERATION_AMPLITUDE = 1.6;\nvar DECELERATION_FACTOR = 325;\nvar TRACKER_TIMEOUT = 100;\n\nvar ReactTouchHandler = /*#__PURE__*/function () {\n  /**\n   * onTouchScroll is the callback that will be called with right frame rate if\n   * any touch events happened\n   * onTouchScroll should is to be called with two arguments: deltaX and deltaY in\n   * this order\n   */\n  function ReactTouchHandler(\n  /*function*/\n  onTouchScroll,\n  /*boolean|function*/\n  handleScrollX,\n  /*boolean|function*/\n  handleScrollY,\n  /*?boolean*/\n  preventDefault,\n  /*?boolean*/\n  stopPropagation) {\n    _classCallCheck(this, ReactTouchHandler); // The animation frame id for the drag scroll\n\n\n    this._dragAnimationId = null; // The interval id for tracking the drag velocity\n\n    this._trackerId = null; // Used to track the drag scroll delta while waiting for an animation frame\n\n    this._deltaX = 0;\n    this._deltaY = 0; // The last touch we processed while dragging.  Used to compute the delta and velocity above\n\n    this._lastTouchX = 0;\n    this._lastTouchY = 0; // Used to track a moving average of the scroll velocity while dragging\n\n    this._velocityX = 0;\n    this._velocityY = 0; // An accummulated drag scroll delta used to calculate velocity\n\n    this._accumulatedDeltaX = 0;\n    this._accumulatedDeltaY = 0; // Timestamp from the last interval frame we used to track velocity\n\n    this._lastFrameTimestamp = Date.now(); // Timestamp from the last animation frame we used to autoscroll after drag stop\n\n    this._autoScrollTimestamp = Date.now();\n\n    if (typeof handleScrollX !== 'function') {\n      handleScrollX = handleScrollX ? _emptyFunction[\"default\"].thatReturnsTrue : _emptyFunction[\"default\"].thatReturnsFalse;\n    }\n\n    if (typeof handleScrollY !== 'function') {\n      handleScrollY = handleScrollY ? _emptyFunction[\"default\"].thatReturnsTrue : _emptyFunction[\"default\"].thatReturnsFalse;\n    }\n\n    this._handleScrollX = handleScrollX;\n    this._handleScrollY = handleScrollY;\n    this._preventDefault = preventDefault;\n    this._stopPropagation = stopPropagation;\n    this._onTouchScrollCallback = onTouchScroll;\n    this._didTouchMove = this._didTouchMove.bind(this);\n    this._track = this._track.bind(this);\n    this._autoScroll = this._autoScroll.bind(this);\n    this._startAutoScroll = this._startAutoScroll.bind(this);\n    this.onTouchStart = this.onTouchStart.bind(this);\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n    this.onTouchMove = this.onTouchMove.bind(this);\n    this.onTouchCancel = this.onTouchCancel.bind(this);\n  }\n\n  _createClass(ReactTouchHandler, [{\n    key: \"onTouchStart\",\n    value: function onTouchStart(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      } // Start tracking drag delta for scrolling\n\n\n      this._lastTouchX = event.touches[0].pageX;\n      this._lastTouchY = event.touches[0].pageY; // Reset our velocity and intermediate data used to compute velocity\n\n      this._velocityX = 0;\n      this._velocityY = 0;\n      this._accumulatedDeltaX = 0;\n      this._accumulatedDeltaY = 0;\n      this._lastFrameTimestamp = Date.now(); // Setup interval for tracking velocity\n\n      clearInterval(this._trackerId);\n      this._trackerId = setInterval(this._track, TRACKER_TIMEOUT);\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      } // Stop tracking velocity\n\n\n      clearInterval(this._trackerId);\n      this._trackerId = null; // Initialize decelerating autoscroll on drag stop\n\n      (0, _requestAnimationFramePolyfill[\"default\"])(this._startAutoScroll);\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchCancel\",\n    value: function onTouchCancel(\n    /*object*/\n    event) {\n      // Stop tracking velocity\n      clearInterval(this._trackerId);\n      this._trackerId = null;\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchMove\",\n    value: function onTouchMove(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      }\n\n      var moveX = event.touches[0].pageX;\n      var moveY = event.touches[0].pageY; // Compute delta scrolled since last drag\n      // Mobile, scrolling is inverted\n\n      this._deltaX = MOVE_AMPLITUDE * (this._lastTouchX - moveX);\n      this._deltaY = MOVE_AMPLITUDE * (this._lastTouchY - moveY);\n\n      var handleScrollX = this._handleScrollX(this._deltaX, this._deltaY);\n\n      var handleScrollY = this._handleScrollY(this._deltaY, this._deltaX);\n\n      if (!handleScrollX && !handleScrollY) {\n        return;\n      } // If we can handle scroll update last touch for computing delta\n\n\n      if (handleScrollX) {\n        this._lastTouchX = moveX;\n      } else {\n        this._deltaX = 0;\n      }\n\n      if (handleScrollY) {\n        this._lastTouchY = moveY;\n      } else {\n        this._deltaY = 0;\n      } // The event will result in a scroll to the table, so there's no need to also let the parent containers scroll\n\n\n      if (!event.defaultPrevented) {\n        event.preventDefault();\n      } // Ensure minimum delta magnitude is met to avoid jitter\n\n\n      var changed = false;\n\n      if (Math.abs(this._deltaX) > 2 || Math.abs(this._deltaY) > 2) {\n        if (this._stopPropagation) {\n          event.stopPropagation();\n        }\n\n        changed = true;\n      } // Request animation frame to trigger scroll of computed delta\n\n\n      if (changed === true && this._dragAnimationId === null) {\n        this._dragAnimationId = (0, _requestAnimationFramePolyfill[\"default\"])(this._didTouchMove);\n      }\n    }\n    /**\n     * Fire scroll callback based on computed drag delta.\n     * Also track accummulated delta so we can calculate velocity\n     */\n\n  }, {\n    key: \"_didTouchMove\",\n    value: function _didTouchMove() {\n      this._dragAnimationId = null;\n\n      this._onTouchScrollCallback(this._deltaX, this._deltaY);\n\n      this._accumulatedDeltaX += this._deltaX;\n      this._accumulatedDeltaY += this._deltaY;\n      this._deltaX = 0;\n      this._deltaY = 0;\n    }\n    /**\n     * Compute velocity based on a weighted average of drag over last 100 ms and\n     * previous velocity.  Combining into a moving average results in a smoother scroll.\n     */\n\n  }, {\n    key: \"_track\",\n    value: function _track() {\n      var now = Date.now();\n      var elapsed = now - this._lastFrameTimestamp;\n      var oldVelocityX = this._velocityX;\n      var oldVelocityY = this._velocityY; // We compute velocity using a weighted average of the current velocity and the previous velocity\n      // If the previous velocity is 0, put the full weight on the last 100 ms\n\n      var weight = 0.8;\n\n      if (elapsed < TRACKER_TIMEOUT) {\n        weight *= elapsed / TRACKER_TIMEOUT;\n      }\n\n      if (oldVelocityX === 0 && oldVelocityY === 0) {\n        weight = 1;\n      } // Formula for computing weighted average of velocity\n\n\n      this._velocityX = weight * (TRACKER_TIMEOUT * this._accumulatedDeltaX / (1 + elapsed));\n\n      if (weight < 1) {\n        this._velocityX += (1 - weight) * oldVelocityX;\n      }\n\n      this._velocityY = weight * (TRACKER_TIMEOUT * this._accumulatedDeltaY / (1 + elapsed));\n\n      if (weight < 1) {\n        this._velocityY += (1 - weight) * oldVelocityY;\n      }\n\n      this._accumulatedDeltaX = 0;\n      this._accumulatedDeltaY = 0;\n      this._lastFrameTimestamp = now;\n    }\n    /**\n     * To kick off deceleration / momentum scrolling,\n     * handle any scrolling from a drag which was waiting for an animation frame\n     * Then update our velocity\n     * Finally start the momentum scrolling handler (autoScroll)\n     */\n\n  }, {\n    key: \"_startAutoScroll\",\n    value: function _startAutoScroll() {\n      this._autoScrollTimestamp = Date.now();\n\n      if (this._deltaX > 0 || this.deltaY > 0) {\n        this._didTouchMove();\n      }\n\n      this._track();\n\n      this._autoScroll();\n    }\n    /**\n     * Compute a scroll delta with an exponential decay based on time elapsed since drag was released.\n     * This is called recursively on animation frames until the delta is below a threshold (5 pixels)\n     */\n\n  }, {\n    key: \"_autoScroll\",\n    value: function _autoScroll() {\n      var elapsed = Date.now() - this._autoScrollTimestamp;\n\n      var factor = DECELERATION_AMPLITUDE * Math.exp(-elapsed / DECELERATION_FACTOR);\n      var deltaX = factor * this._velocityX;\n      var deltaY = factor * this._velocityY;\n\n      if (Math.abs(deltaX) <= 5 || !this._handleScrollX(deltaX, deltaY)) {\n        deltaX = 0;\n      }\n\n      if (Math.abs(deltaY) <= 5 || !this._handleScrollY(deltaY, deltaX)) {\n        deltaY = 0;\n      }\n\n      if (deltaX !== 0 || deltaY !== 0) {\n        this._onTouchScrollCallback(deltaX, deltaY);\n\n        (0, _requestAnimationFramePolyfill[\"default\"])(this._autoScroll);\n      }\n    }\n  }]);\n\n  return ReactTouchHandler;\n}();\n\nvar _default = ReactTouchHandler;\nexports[\"default\"] = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","_emptyFunction","_interopRequireDefault","require","_requestAnimationFramePolyfill","obj","__esModule","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","MOVE_AMPLITUDE","DECELERATION_AMPLITUDE","DECELERATION_FACTOR","TRACKER_TIMEOUT","ReactTouchHandler","onTouchScroll","handleScrollX","handleScrollY","preventDefault","stopPropagation","_dragAnimationId","_trackerId","_deltaX","_deltaY","_lastTouchX","_lastTouchY","_velocityX","_velocityY","_accumulatedDeltaX","_accumulatedDeltaY","_lastFrameTimestamp","Date","now","_autoScrollTimestamp","thatReturnsTrue","thatReturnsFalse","_handleScrollX","_handleScrollY","_preventDefault","_stopPropagation","_onTouchScrollCallback","_didTouchMove","bind","_track","_autoScroll","_startAutoScroll","onTouchStart","onTouchEnd","onTouchMove","onTouchCancel","event","touches","pageX","pageY","clearInterval","setInterval","moveX","moveY","defaultPrevented","changed","Math","abs","elapsed","oldVelocityX","oldVelocityY","weight","deltaY","factor","exp","deltaX","_default"],"sources":["D:/myirancell/myirancell/node_modules/fixed-data-table-2/internal/ReactTouchHandler.js"],"sourcesContent":["/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * This is utility that handles touch events and calls provided touch\n * callback with correct frame rate.\n * Deceleration logic based on http://ariya.ofilabs.com/2013/11/javascript-kinetic-scrolling-part-2.html\n *\n * @providesModule ReactTouchHandler\n * @typechecks\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _emptyFunction = _interopRequireDefault(require('././vendor_upstream/core/emptyFunction'));\n\nvar _requestAnimationFramePolyfill = _interopRequireDefault(require('././vendor_upstream/core/requestAnimationFramePolyfill'));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MOVE_AMPLITUDE = 1.6;\nvar DECELERATION_AMPLITUDE = 1.6;\nvar DECELERATION_FACTOR = 325;\nvar TRACKER_TIMEOUT = 100;\n\nvar ReactTouchHandler = /*#__PURE__*/function () {\n  /**\n   * onTouchScroll is the callback that will be called with right frame rate if\n   * any touch events happened\n   * onTouchScroll should is to be called with two arguments: deltaX and deltaY in\n   * this order\n   */\n  function ReactTouchHandler(\n  /*function*/\n  onTouchScroll,\n  /*boolean|function*/\n  handleScrollX,\n  /*boolean|function*/\n  handleScrollY,\n  /*?boolean*/\n  preventDefault,\n  /*?boolean*/\n  stopPropagation) {\n    _classCallCheck(this, ReactTouchHandler);\n\n    // The animation frame id for the drag scroll\n    this._dragAnimationId = null; // The interval id for tracking the drag velocity\n\n    this._trackerId = null; // Used to track the drag scroll delta while waiting for an animation frame\n\n    this._deltaX = 0;\n    this._deltaY = 0; // The last touch we processed while dragging.  Used to compute the delta and velocity above\n\n    this._lastTouchX = 0;\n    this._lastTouchY = 0; // Used to track a moving average of the scroll velocity while dragging\n\n    this._velocityX = 0;\n    this._velocityY = 0; // An accummulated drag scroll delta used to calculate velocity\n\n    this._accumulatedDeltaX = 0;\n    this._accumulatedDeltaY = 0; // Timestamp from the last interval frame we used to track velocity\n\n    this._lastFrameTimestamp = Date.now(); // Timestamp from the last animation frame we used to autoscroll after drag stop\n\n    this._autoScrollTimestamp = Date.now();\n\n    if (typeof handleScrollX !== 'function') {\n      handleScrollX = handleScrollX ? _emptyFunction[\"default\"].thatReturnsTrue : _emptyFunction[\"default\"].thatReturnsFalse;\n    }\n\n    if (typeof handleScrollY !== 'function') {\n      handleScrollY = handleScrollY ? _emptyFunction[\"default\"].thatReturnsTrue : _emptyFunction[\"default\"].thatReturnsFalse;\n    }\n\n    this._handleScrollX = handleScrollX;\n    this._handleScrollY = handleScrollY;\n    this._preventDefault = preventDefault;\n    this._stopPropagation = stopPropagation;\n    this._onTouchScrollCallback = onTouchScroll;\n    this._didTouchMove = this._didTouchMove.bind(this);\n    this._track = this._track.bind(this);\n    this._autoScroll = this._autoScroll.bind(this);\n    this._startAutoScroll = this._startAutoScroll.bind(this);\n    this.onTouchStart = this.onTouchStart.bind(this);\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n    this.onTouchMove = this.onTouchMove.bind(this);\n    this.onTouchCancel = this.onTouchCancel.bind(this);\n  }\n\n  _createClass(ReactTouchHandler, [{\n    key: \"onTouchStart\",\n    value: function onTouchStart(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      } // Start tracking drag delta for scrolling\n\n\n      this._lastTouchX = event.touches[0].pageX;\n      this._lastTouchY = event.touches[0].pageY; // Reset our velocity and intermediate data used to compute velocity\n\n      this._velocityX = 0;\n      this._velocityY = 0;\n      this._accumulatedDeltaX = 0;\n      this._accumulatedDeltaY = 0;\n      this._lastFrameTimestamp = Date.now(); // Setup interval for tracking velocity\n\n      clearInterval(this._trackerId);\n      this._trackerId = setInterval(this._track, TRACKER_TIMEOUT);\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      } // Stop tracking velocity\n\n\n      clearInterval(this._trackerId);\n      this._trackerId = null; // Initialize decelerating autoscroll on drag stop\n\n      (0, _requestAnimationFramePolyfill[\"default\"])(this._startAutoScroll);\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchCancel\",\n    value: function onTouchCancel(\n    /*object*/\n    event) {\n      // Stop tracking velocity\n      clearInterval(this._trackerId);\n      this._trackerId = null;\n\n      if (this._stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchMove\",\n    value: function onTouchMove(\n    /*object*/\n    event) {\n      if (this._preventDefault) {\n        event.preventDefault();\n      }\n\n      var moveX = event.touches[0].pageX;\n      var moveY = event.touches[0].pageY; // Compute delta scrolled since last drag\n      // Mobile, scrolling is inverted\n\n      this._deltaX = MOVE_AMPLITUDE * (this._lastTouchX - moveX);\n      this._deltaY = MOVE_AMPLITUDE * (this._lastTouchY - moveY);\n\n      var handleScrollX = this._handleScrollX(this._deltaX, this._deltaY);\n\n      var handleScrollY = this._handleScrollY(this._deltaY, this._deltaX);\n\n      if (!handleScrollX && !handleScrollY) {\n        return;\n      } // If we can handle scroll update last touch for computing delta\n\n\n      if (handleScrollX) {\n        this._lastTouchX = moveX;\n      } else {\n        this._deltaX = 0;\n      }\n\n      if (handleScrollY) {\n        this._lastTouchY = moveY;\n      } else {\n        this._deltaY = 0;\n      } // The event will result in a scroll to the table, so there's no need to also let the parent containers scroll\n\n\n      if (!event.defaultPrevented) {\n        event.preventDefault();\n      } // Ensure minimum delta magnitude is met to avoid jitter\n\n\n      var changed = false;\n\n      if (Math.abs(this._deltaX) > 2 || Math.abs(this._deltaY) > 2) {\n        if (this._stopPropagation) {\n          event.stopPropagation();\n        }\n\n        changed = true;\n      } // Request animation frame to trigger scroll of computed delta\n\n\n      if (changed === true && this._dragAnimationId === null) {\n        this._dragAnimationId = (0, _requestAnimationFramePolyfill[\"default\"])(this._didTouchMove);\n      }\n    }\n    /**\n     * Fire scroll callback based on computed drag delta.\n     * Also track accummulated delta so we can calculate velocity\n     */\n\n  }, {\n    key: \"_didTouchMove\",\n    value: function _didTouchMove() {\n      this._dragAnimationId = null;\n\n      this._onTouchScrollCallback(this._deltaX, this._deltaY);\n\n      this._accumulatedDeltaX += this._deltaX;\n      this._accumulatedDeltaY += this._deltaY;\n      this._deltaX = 0;\n      this._deltaY = 0;\n    }\n    /**\n     * Compute velocity based on a weighted average of drag over last 100 ms and\n     * previous velocity.  Combining into a moving average results in a smoother scroll.\n     */\n\n  }, {\n    key: \"_track\",\n    value: function _track() {\n      var now = Date.now();\n      var elapsed = now - this._lastFrameTimestamp;\n      var oldVelocityX = this._velocityX;\n      var oldVelocityY = this._velocityY; // We compute velocity using a weighted average of the current velocity and the previous velocity\n      // If the previous velocity is 0, put the full weight on the last 100 ms\n\n      var weight = 0.8;\n\n      if (elapsed < TRACKER_TIMEOUT) {\n        weight *= elapsed / TRACKER_TIMEOUT;\n      }\n\n      if (oldVelocityX === 0 && oldVelocityY === 0) {\n        weight = 1;\n      } // Formula for computing weighted average of velocity\n\n\n      this._velocityX = weight * (TRACKER_TIMEOUT * this._accumulatedDeltaX / (1 + elapsed));\n\n      if (weight < 1) {\n        this._velocityX += (1 - weight) * oldVelocityX;\n      }\n\n      this._velocityY = weight * (TRACKER_TIMEOUT * this._accumulatedDeltaY / (1 + elapsed));\n\n      if (weight < 1) {\n        this._velocityY += (1 - weight) * oldVelocityY;\n      }\n\n      this._accumulatedDeltaX = 0;\n      this._accumulatedDeltaY = 0;\n      this._lastFrameTimestamp = now;\n    }\n    /**\n     * To kick off deceleration / momentum scrolling,\n     * handle any scrolling from a drag which was waiting for an animation frame\n     * Then update our velocity\n     * Finally start the momentum scrolling handler (autoScroll)\n     */\n\n  }, {\n    key: \"_startAutoScroll\",\n    value: function _startAutoScroll() {\n      this._autoScrollTimestamp = Date.now();\n\n      if (this._deltaX > 0 || this.deltaY > 0) {\n        this._didTouchMove();\n      }\n\n      this._track();\n\n      this._autoScroll();\n    }\n    /**\n     * Compute a scroll delta with an exponential decay based on time elapsed since drag was released.\n     * This is called recursively on animation frames until the delta is below a threshold (5 pixels)\n     */\n\n  }, {\n    key: \"_autoScroll\",\n    value: function _autoScroll() {\n      var elapsed = Date.now() - this._autoScrollTimestamp;\n\n      var factor = DECELERATION_AMPLITUDE * Math.exp(-elapsed / DECELERATION_FACTOR);\n      var deltaX = factor * this._velocityX;\n      var deltaY = factor * this._velocityY;\n\n      if (Math.abs(deltaX) <= 5 || !this._handleScrollX(deltaX, deltaY)) {\n        deltaX = 0;\n      }\n\n      if (Math.abs(deltaY) <= 5 || !this._handleScrollY(deltaY, deltaX)) {\n        deltaY = 0;\n      }\n\n      if (deltaX !== 0 || deltaY !== 0) {\n        this._onTouchScrollCallback(deltaX, deltaY);\n\n        (0, _requestAnimationFramePolyfill[\"default\"])(this._autoScroll);\n      }\n    }\n  }]);\n\n  return ReactTouchHandler;\n}();\n\nvar _default = ReactTouchHandler;\nexports[\"default\"] = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}